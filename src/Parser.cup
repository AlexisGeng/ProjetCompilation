/*
 * analyseur syntaxique  d'un langage fictif:
 *
 * auteurs : Laurene Cladt, Alexis Geng, Benjamin Rath, Enzo Proux
 * (c) 2017
 */ 

package fr.ul.miage.compilation.generated;
import fr.ul.*;
import fr.ul.miage.structure.arbre.*;
import fr.ul.miage.tablesymboles.*;
import fr.ul.miage.generateur.*;
import java.util.ArrayList;
import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.Map;


parser code {:
	public Arbre getArbre(){
		return action_obj.arbre;
	}
	
	public TableSymboles getTDS(){
		return action_obj.tds;
	}
:}

action code{:
public Noeud prog= new Noeud(Noeud.PRINCIPAL_NOD,null);
public Arbre arbre = new Arbre(prog);
public TableSymboles tds = new TableSymboles();
public ArrayList<Noeud> tableauFct = new ArrayList();
public int nbParam = 0;
public int nbLoc = 0;
public int nbFonction = 0;
public String nomFonction;
public ArrayList<Fonction> fonctionDeclare = new ArrayList();
public ArrayList<Fonction> fonctionAppele = new ArrayList();


:}

/* la grammaire */

terminal PV, VIRGULE, FLECHE, PO, PF, DP,  SYM, INF, SUP, EGAL, INFEGAL, SUPEGAL, DIFF, DEF, ENDDEF, MAIN, RETURN, WHILE, ENDWHILE, IF, ENDIF, ELSEIF, ELSE ;
terminal String NOM, TYPE;
terminal Integer NBR,ADD,SUB,MUL,DIV;
/*
 * PV = ;
 * VIRGULE = ,
 * FLECHE = <-
 * PO = (
 * PF = )
 * DP = :
 * NOM = le nom de la variable/fonction
 * SYM = symbole math. + * - / % etc.
 * NBR = 1,2,... nombre
 * INF = <
 * SUP = >
 * EGAL = =
 * INFEGAL = <=
 * SUPEGAL = >=
 * DIFF = !=
 * TYPE = nom du type 
*/



non terminal programme, declaration, decVar, decFonc, nomFonc, main, return, argFonc, autreExpr, sinonsi, sinon, condition, comp ;
non terminal Noeud s;
non terminal Integer defVar, operation, arguments, exprLoc ;
non terminal ArrayList<Noeud> bloc, declaration_loc, autreVar,blocFonc;
non terminal Noeud fonction, boucle, si, expr, varExpr;




//Precedences added by Eclipse plugin
precedence nonassoc RETURN;	// Inserted by Eclipse plugin
precedence nonassoc DEF;	// Inserted by Eclipse plugin

start with programme;

programme ::= declaration ;

declaration ::= decVar declaration
			| decFonc declaration
			| ;

decVar ::= TYPE NOM:nom autreVar PV {:tds.insertionVerifValeur(nom, null, "int", "globale", nbLoc, nbParam);
															 :} 
															 | TYPE NOM:nom autreVar FLECHE NBR:nbr PV {:tds.insertionVerifValeur(nom, Integer.toString(nbr), "int", "globale", nbLoc, nbParam); RESULT=nbr;:}
															 | declaration_loc:var  decVar exprLoc:expr PV 	{:tds.ajouterValeurListeTemporaire(var, expr);Noeud n = new Noeud(Noeud.DEC);n.getFils().addAll(var);RESULT = n;:}
															 |NOM:nom NBR:nbr PV {:tds.insertionVerifValeur(nom, Integer.toString(nbr), "int", "loc", nbLoc, nbParam); :}
															 ;
															 
exprLoc ::= FLECHE NBR:nb {:RESULT = nb;:}
		| 
		; 
		
declaration_loc ::= TYPE NOM:nom autreVar:apres {:tds.stockTemporaire(nom, "int", "loc", "var", nbLoc, nbParam, nbFonction);
												nbLoc ++;
												apres.add(new Noeud(Noeud.NOM,nom));
											
												RESULT=apres;	
												:}
				| NOM:nom autreVar:apres
				;

autreVar ::= VIRGULE NOM:nom autreVar:l {:tds.insertionVerifValeur(nom, null, "int", "globale", nbLoc, nbParam); 
											:}
				| {: RESULT = new ArrayList<Noeud>();:};

decFonc ::= DEF nomFonc:nom DP bloc:bloc ENDDEF PV {:Noeud n = new Noeud(Noeud.FCT, nom);n.getFils().addAll(bloc); 	tableauFct.add(n);:}  
		| DEF TYPE MAIN PO PF DP blocFonc:b ENDDEF PV {:fonctionDeclare.add(new Fonction("main","void",0));tds.insertionVerifValeur("main", null, "void", "glob", "fonction", nbLoc, 0);
						 																			Noeud n = new Noeud(Noeud.FCT, "main");
																									n.getFils().addAll(b);
																									tableauFct.add(n);
																									RESULT = tableauFct;:}
		;



//si main, return true pour "la fonction possède un main" (pour vérifier que la syntaxe est correcte) -> à implémenter

nomFonc ::= TYPE:type NOM:nom PO arguments:p PF {:fonctionDeclare.add(new Fonction(nom,type,p));nomFonction = nom ; tds.insertionVerifValeur(nom, null, type, "glob", "fonction", nbLoc, p);RESULT = tableauFct; :} ;

//main ::= DEF TYPE MAIN PO PF DP bloc ENDDEF PV ;

arguments ::= TYPE NOM:nom arguments {:nbParam ++;
									tds.stockTemporaire(nom, "int", "loc", "param", nbLoc, nbParam, nbFonction);
									RESULT = nbParam;
									:} 
									| VIRGULE TYPE NOM:nom arguments {:nbParam ++;
										tds.stockTemporaire(nom, "int", "loc", "param", nbLoc, nbParam, nbFonction);
										RESULT = nbParam;:} 
									|{:RESULT = 0 ; :}
									 ;





blocFonc ::= NOM:nom FLECHE expr:e  PV blocFonc:i {:Noeud n = new Noeud(Noeud.EGAL);
																n.addFils(new Noeud(Noeud.NOM,nom));
																n.addFils(e);
																i.add(0,n);
																RESULT = i;
													:}
			| boucle:bcl bloc:b {:b.add(0,bcl);RESULT=b;:} | si:c bloc:b {:b.add(0,c);RESULT=b;:} | fonction:f PV bloc:b {:b.add(0,f);RESULT=b;:} | return |  {: RESULT = new ArrayList<Noeud>();:}  ;


expr ::=  varExpr:n2 operation:i  {: Noeud n = new Noeud(i);
									n.addFils(n2);
									RESULT = n;:};
									

operation ::= ADD varExpr:varexp operation {: RESULT = Noeud.ADD;:}
			| SUB varExpr:varexp operation {: RESULT = Noeud.SUB;:} 
			| MUL varExpr:varexp operation  {: RESULT = Noeud.MUL;:}
			| DIV varExpr:varexp operation{: RESULT = Noeud.DIV;:}
			|  
			; 

varExpr ::= NOM | fonction | NBR:nbr {:RESULT = new Noeud(Noeud.CONST,nbr);:}| PO expr PF ;

return ::= RETURN expr PV ;

fonction ::= NOM PO argFonc PF ;
argFonc ::= expr autreExpr | ;

autreExpr ::= VIRGULE expr autreExpr | ;


boucle ::= WHILE PO condition PF DP bloc ENDWHILE PV ;

si ::= IF PO condition PF DP bloc sinonsi sinon ENDIF PV ;

sinonsi ::= ELSEIF PO condition PF DP bloc sinonsi | ;

sinon ::= ELSE DP bloc | ;

condition ::= expr comp expr ;

comp ::= INF | SUP | EGAL | SUPEGAL | INFEGAL | DIFF ;
              


