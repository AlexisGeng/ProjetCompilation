/*
 * analyseur syntaxique  d'un langage fictif:
 *
 * auteurs : Laurene Cladt, Alexis Geng, Benjamin Rath, Enzo Proux
 * (c) 2017
 */ 
package fr.ul.miage.compilation.generated;

/* la grammaire */

terminal PV, VIRGULE, FLECHE, PO, PF, DP, NOM, SYM, NBR, INF, SUP, EGAL, INFEGAL, SUPEGAL, DIFF, TYPE, DEF, ENDDEF, MAIN, RETURN, WHILE, ENDWHILE, IF, ENDIF, ELSEIF, ELSE ;
/*
 * PV = ;
 * VIRGULE = ,
 * FLECHE = <-
 * PO = (
 * PF = )
 * DP = :
 * NOM = le nom de la variable/fonction
 * SYM = symbole math. + * - / % etc.
 * NBR = 1,2,... nombre
 * INF = <
 * SUP = >
 * EGAL = =
 * INFEGAL = <=
 * SUPEGAL = >=
 * DIFF = !=
 * TYPE = nom du type 
*/

non terminal programme, declaration, decVar, defVar, autreVar, decFonc, nomFonc, main, arguments, autreArgument, bloc, blocFonc, return, fonction, argFonc, expr, autreExpr, operation, varExpr, boucle, si, sinonsi, sinon, condition, comp ;

//Precedences added by Eclipse plugin
precedence nonassoc RETURN;	// Inserted by Eclipse plugin
precedence nonassoc DEF;	// Inserted by Eclipse plugin

start with programme;

programme ::= declaration ;

declaration ::= decVar declaration | decFonc declaration | ;

decVar ::= TYPE NOM autreVar PV | TYPE defVar ;

defVar ::= NOM FLECHE expr PV ;

autreVar ::= VIRGULE NOM autreVar | ;

decFonc ::= DEF nomFonc DP bloc ENDDEF PV | DEF TYPE MAIN PO PF DP bloc ENDDEF PV ;
//si main, return true pour "la fonction possède un main" (pour vérifier que la syntaxe est correcte) -> à implémenter

nomFonc ::= TYPE NOM PO arguments PF ;

//main ::= DEF TYPE MAIN PO PF DP bloc ENDDEF PV ;

arguments ::= TYPE NOM autreArgument | ;

autreArgument ::= VIRGULE TYPE NOM autreArgument | ;

bloc ::= blocFonc return | blocFonc ;

blocFonc ::= decVar bloc | boucle bloc | si bloc | fonction PV bloc | defVar bloc | ;

return ::= RETURN expr PV ;

fonction ::= NOM PO argFonc PF ;
argFonc ::= expr autreExpr | ;

autreExpr ::= VIRGULE expr autreExpr | ;

expr ::= varExpr operation ;

operation ::= SYM varExpr operation | ; 

varExpr ::= NOM | fonction | NBR | PO expr PF ;

boucle ::= WHILE PO condition PF DP bloc ENDWHILE PV ;

si ::= IF PO condition PF DP bloc sinonsi sinon ENDIF PV ;

sinonsi ::= ELSEIF PO condition PF DP bloc sinonsi | ;

sinon ::= ELSE DP bloc | ;

condition ::= expr comp expr ;

comp ::= INF | SUP | EGAL | SUPEGAL | INFEGAL | DIFF ;
              